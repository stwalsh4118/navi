# 42-4 Implement notification manager with cooldown

[Back to task list](./tasks.md)

## Description

Create a `Notifier` that orchestrates audio playback and TTS, enforcing per-session cooldowns and checking trigger configuration. This is the main API surface that the TUI will call.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-14 08:41:13 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-14 08:49:15 | Status Change | Proposed | Agreed | User requested implementation of PBI 42 | AI_Agent |
| 2026-02-14 08:49:15 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2026-02-14 08:50:20 | Status Change | InProgress | Review | Implementation complete | AI_Agent |
| 2026-02-15 11:48:19 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. `Notifier` type with methods:
   - `NewNotifier(cfg *Config) *Notifier` — constructs notifier with player, TTS, and cooldown state
   - `Notify(sessionName, newStatus string)` — the main entry point: checks triggers, cooldown, then plays sound + TTS
   - `Enabled() bool` — whether audio notifications are active (config enabled + at least one backend available)
2. Per-session cooldown tracking:
   - Map of `sessionName → lastNotifiedTime`
   - Skip notification if within cooldown window (configurable seconds from config)
   - Cooldown is per-session, not global — different sessions can trigger independently
3. Trigger checking:
   - Only notify if `config.Triggers[newStatus]` is `true`
   - If status not in triggers map, skip silently
4. Playback sequencing:
   - Play sound file first (if configured for that status)
   - Then speak TTS announcement (if TTS enabled)
   - Both are fire-and-forget, sequencing is best-effort (small delay between)
5. Graceful when no backends available — `Notify()` becomes a no-op

## Implementation Plan

1. Create `internal/audio/notifier.go`
2. Create `internal/audio/notifier_test.go`
3. `Notifier` holds references to `Player`, `TTS`, `Config`, and `cooldowns map[string]time.Time`
4. `Notify()` flow:
   - Check `config.Enabled` → return if false
   - Check `config.Triggers[newStatus]` → return if false or missing
   - Check cooldown for session → return if within window
   - Update cooldown timestamp
   - If sound file configured for status → `player.Play(file)`
   - If TTS enabled → format announcement → `tts.Speak(text)`
5. Use `sync.Mutex` to protect cooldown map (called from TUI goroutine)

## Test Plan

- **Objective**: Verify the notifier correctly orchestrates player, TTS, and cooldown
- **Mocking Strategy**: Use interfaces for Player and TTS to inject test doubles that record calls
- **Key Scenarios**:
  - **Trigger enabled**: `Notify("mysession", "permission")` with permission trigger enabled → player.Play called with correct file, TTS.Speak called with formatted text
  - **Trigger disabled**: `Notify("mysession", "working")` with working trigger disabled → no calls to player or TTS
  - **Cooldown active**: Two rapid `Notify()` calls for same session → only first triggers playback
  - **Cooldown expired**: `Notify()` after cooldown window → triggers playback again
  - **Different sessions**: Two sessions notified within cooldown → both trigger (cooldown is per-session)
  - **No sound file mapped**: Status triggered but no file in config → TTS still speaks, no player call
  - **Disabled config**: `config.Enabled = false` → nothing fires
  - **No backends**: Player and TTS both unavailable → no panics, `Notify()` is no-op
- **Success Criteria**: All scenarios pass with injected test doubles

## Verification

- `go test ./internal/audio` passed

## Files Modified

- `internal/audio/notifier.go` (new)
- `internal/audio/notifier_test.go` (new)
