# 44-2: Create internal/monitor package with AttachMonitor

[Back to task list](./tasks.md)

## Description

Create an `internal/monitor` package with an `AttachMonitor` struct that runs a background polling loop in a goroutine. It reads session status files, detects status transitions, and triggers `audio.Notifier` on changes. It accepts a `context.Context` for clean cancellation and supports state handoff (receiving initial state, returning final state).

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-15 17:05:29 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-15 17:16:19 | Status Change | Proposed | Agreed | User requested implementation of PBI 44 | AI_Agent |
| 2026-02-15 17:16:19 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2026-02-15 17:19:16 | Status Change | InProgress | Review | Implementation complete | AI_Agent |
| 2026-02-15 17:29:50 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. Create `internal/monitor/monitor.go` with:
   - `type AttachMonitor struct` — holds notifier, status dir, poll interval, state
   - `func New(notifier *audio.Notifier, statusDir string, pollInterval time.Duration) *AttachMonitor`
   - `func (m *AttachMonitor) Start(ctx context.Context, initialStates map[string]string)` — starts the background goroutine
   - `func (m *AttachMonitor) States() map[string]string` — returns the current session states (thread-safe, for handoff after cancellation)
2. The polling loop must:
   - Call `session.ReadStatusFiles(statusDir)` on each tick
   - Compare current states against last-known states
   - Call `notifier.Notify(sessionName, newStatus)` on transitions
   - Skip the first poll if `initialStates` is non-empty (already initialized)
   - Sleep for `pollInterval` between polls
   - Exit cleanly when `ctx` is cancelled
3. State access must be thread-safe (mutex-protected) since `States()` is called from a different goroutine than the polling loop
4. The monitor must not panic on nil notifier (graceful no-op for notifications, still tracks state)

## Implementation Plan

1. Create `internal/monitor/monitor.go`:
   - `AttachMonitor` struct: `notifier *audio.Notifier`, `statusDir string`, `interval time.Duration`, `mu sync.Mutex`, `states map[string]string`
   - `New()` constructor
   - `Start(ctx, initialStates)`:
     - Copy `initialStates` into `m.states`
     - Launch goroutine with `time.Ticker` and `ctx.Done()` select loop
     - On each tick: read files, detect changes, notify, update states
   - `States()`: lock mutex, copy and return states map
2. Status change detection logic mirrors `Model.detectStatusChanges()`:
   - Build `currentStates` map from session list
   - Compare against `m.states`
   - For each changed status, call `m.notifier.Notify()`
   - Update `m.states` to `currentStates`

## Test Plan

**Objective**: Verify monitor starts, polls, detects changes, notifies, and stops cleanly.

- Unit test: `New()` creates a valid monitor with correct fields
- Unit test: `Start()` with mock notifier and temp status files; write a status file, verify notification fires
- Unit test: `Start()` with `initialStates` skips first-poll initialization
- Unit test: `States()` returns current states after polling
- Unit test: Context cancellation stops the goroutine (verify no more polls after cancel)
- Unit test: Nil notifier doesn't panic, still tracks states
- Race test: Call `States()` concurrently with polling loop (run with `-race`)

## Verification

- `go vet ./...`
- `go test ./... -race`
- `coderabbit review --base main --plain`

## Files Modified

- `internal/monitor/monitor.go`
- `internal/monitor/monitor_test.go`
- `docs/api-specs/monitor/monitor-api.md`
- `docs/delivery/44/44-2.md`
- `docs/delivery/44/tasks.md`
