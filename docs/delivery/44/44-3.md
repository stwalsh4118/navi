# 44-3: Integrate AttachMonitor into TUI attach flow

[Back to task list](./tasks.md)

## Description

Wire the `AttachMonitor` into the TUI's attach/detach lifecycle. Before `tea.ExecProcess` yields terminal control, start the background monitor with the TUI's current `lastSessionStates`. When the user detaches and `attachDoneMsg` arrives, stop the monitor and absorb its updated states so no duplicate notifications fire.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-15 17:05:29 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-15 17:21:08 | Status Change | Proposed | Agreed | User requested implementation of PBI 44 | AI_Agent |
| 2026-02-15 17:21:08 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2026-02-15 17:21:08 | Status Change | InProgress | Review | Implementation complete | AI_Agent |
| 2026-02-15 17:29:50 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

1. Add fields to `Model`:
   - `attachMonitor *monitor.AttachMonitor` — the active background monitor (nil when not attached)
   - `attachMonitorCancel context.CancelFunc` — cancel function for the monitor's context
2. Modify `attachSession()` and `attachRemoteSession()` to return a `tea.Cmd` that:
   - Creates and starts an `AttachMonitor` with the current `lastSessionStates`
   - Stores the monitor and cancel func on the model
   - Then calls `tea.ExecProcess` (the monitor runs in the background while ExecProcess blocks)
3. On `attachDoneMsg`:
   - Cancel the monitor's context
   - Read final states via `monitor.States()` and assign to `m.lastSessionStates`
   - Clear `m.attachMonitor` and `m.attachMonitorCancel`
   - Continue with existing `pollSessions` refresh
4. The monitor must use the same `session.StatusDir` and `session.PollInterval` as the TUI
5. Both local and remote attach flows must start the monitor

## Implementation Plan

1. Add `attachMonitor` and `attachMonitorCancel` fields to `Model` struct
2. Create helper `func (m *Model) startAttachMonitor()` that:
   - Creates `context.WithCancel(context.Background())`
   - Creates `monitor.New(m.audioNotifier, session.StatusDir, session.PollInterval)`
   - Calls `monitor.Start(ctx, m.lastSessionStates)`
   - Stores monitor and cancel on model
3. Create helper `func (m *Model) stopAttachMonitor()` that:
   - Calls `m.attachMonitorCancel()`
   - Copies `m.attachMonitor.States()` into `m.lastSessionStates`
   - Nils out `m.attachMonitor` and `m.attachMonitorCancel`
4. Modify `attachSession()`: the returned `tea.Cmd` must be wrapped so the model can call `startAttachMonitor()` before the exec. Since `tea.ExecProcess` needs to be returned as a `tea.Cmd`, the approach is:
   - In the `"enter"` key handler (not inside `attachSession()`), call `m.startAttachMonitor()` before returning the `attachSession()` command
5. Modify `attachDoneMsg` handler: call `m.stopAttachMonitor()` before returning `pollSessions`
6. Apply the same pattern to the remote attach path and the search-mode enter path

## Test Plan

**Objective**: Verify the monitor starts on attach and stops on detach with correct state handoff.

- Unit test: After processing Enter key, `m.attachMonitor` is non-nil
- Unit test: After processing `attachDoneMsg`, `m.attachMonitor` is nil
- Unit test: `lastSessionStates` is passed to monitor on start and recovered on stop
- Unit test: Remote attach also starts the monitor
- Unit test: Multiple attach/detach cycles don't leak goroutines or monitors

## Verification

- `go vet ./...`
- `go test ./... -race`
- `coderabbit review --base main --plain` (failed: rate limit exceeded)

## Files Modified

- `internal/tui/model.go`
- `internal/tui/model_test.go`
- `docs/delivery/44/44-3.md`
- `docs/delivery/44/tasks.md`
