# [48-6] Error Recovery and Resilience

[Back to task list](./tasks.md)

## Description

Implement the error recovery strategies specified in the PRD: fallback to cached output on failure, session re-initialization on corruption, and backoff on rate limiting. This wraps the invoker core (48-4) with resilience logic.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-18 08:53:42 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

1. **Non-zero exit**: On non-zero exit code from `claude`, fall back to `LoadCachedOutput()` and mark as stale.
2. **Unparseable JSON**: If `ParseOutput()` returns an error, fall back to cached output with staleness.
3. **Session corruption**: If `--resume` fails (detected via specific exit code or error message pattern), delete session ID via `DeleteSessionID()`, re-initialize, and retry the invocation once without `--resume`.
4. **Rate limiting**: Detect rate-limit signals (exit code or stderr pattern), apply exponential backoff, retry up to 3 times.
5. `InvokeWithRecovery(inbox *InboxPayload) (*PMBriefing, bool, error)` — returns briefing, isStale flag, and error. Only returns error if both invocation AND cache fallback fail.
6. Staleness flag is propagated to the TUI layer for display (consumed in 48-7).
7. Re-initialization preserves memory files — only `session_id` is deleted.

## Implementation Plan

1. Create `internal/pm/recovery.go` with `InvokeWithRecovery()`.
2. Wrap `Invoker.Invoke()` with error classification:
   - Check exit code and stderr for session corruption patterns.
   - Check exit code and stderr for rate-limit patterns.
   - All other non-zero exits → generic failure.
3. Session corruption path: `DeleteSessionID()` → retry `Invoke()` once (as first run).
4. Rate-limit path: exponential backoff (1s, 2s, 4s) with max 3 retries.
5. Fallback path: `LoadCachedOutput()` → set `IsStale = true`.
6. If no cached output exists (first run failure), return error.

## Test Plan

- **Objectives**: Verify each error recovery path produces correct behavior.
- **Mocking Strategy**: Use the command mock from 48-4 to simulate failure modes.
- **Key Scenarios**:
  1. Non-zero exit → falls back to cached output, isStale=true.
  2. Unparseable JSON → falls back to cached output, isStale=true.
  3. Session corruption → deletes session ID, retries without --resume, succeeds.
  4. Session corruption + retry fails → falls back to cache.
  5. Rate limit → retries with backoff, eventually succeeds.
  6. Rate limit + all retries exhausted → falls back to cache.
  7. First-run failure with no cache → returns error.
- **Success Criteria**: Every failure mode has a defined recovery path; memory files are never deleted.

## Verification

_To be filled during implementation._

## Files Modified

_To be filled during implementation._
