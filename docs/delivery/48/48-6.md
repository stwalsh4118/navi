# [48-6] Error Recovery and Resilience

[Back to task list](./tasks.md)

## Description

Implement the error recovery strategies specified in the PRD: fallback to cached output on failure, session re-initialization on corruption, and backoff on rate limiting. This wraps the invoker core (48-4) with resilience logic.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-18 08:53:42 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-18 09:17:38 | Status Change | Proposed | InProgress | Started implementation | AI_Agent |
| 2026-02-18 09:44:25 | Status Change | InProgress | Review | Implementation complete, internal AI review passed (0 critical, 0 high, 1 medium resolved, 5 low deferred) | AI_Agent |
| 2026-02-18 13:05:37 | Status Change | Review | Done | Task completed and verified. Session corruption recovery removed (not applicable with fresh sessions). Rate-limit retries and cache fallback remain. | AI_Agent |

## Requirements

1. **Non-zero exit**: On non-zero exit code from `claude`, fall back to `LoadCachedOutput()` and mark as stale.
2. **Unparseable JSON**: If `ParseOutput()` returns an error, fall back to cached output with staleness.
3. **Session corruption**: If `--resume` fails (detected via specific exit code or error message pattern), delete session ID via `DeleteSessionID()`, re-initialize, and retry the invocation once without `--resume`.
4. **Rate limiting**: Detect rate-limit signals (exit code or stderr pattern), apply exponential backoff, retry up to 3 times.
5. `InvokeWithRecovery(inbox *InboxPayload) (*PMBriefing, bool, error)` — returns briefing, isStale flag, and error. Only returns error if both invocation AND cache fallback fail.
6. Staleness flag is propagated to the TUI layer for display (consumed in 48-7).
7. Re-initialization preserves memory files — only `session_id` is deleted.

## Implementation Plan

1. Create `internal/pm/recovery.go` with `InvokeWithRecovery()`.
2. Wrap `Invoker.Invoke()` with error classification:
   - Check exit code and stderr for session corruption patterns.
   - Check exit code and stderr for rate-limit patterns.
   - All other non-zero exits → generic failure.
3. Session corruption path: `DeleteSessionID()` → retry `Invoke()` once (as first run).
4. Rate-limit path: exponential backoff (1s, 2s, 4s) with max 3 retries.
5. Fallback path: `LoadCachedOutput()` → set `IsStale = true`.
6. If no cached output exists (first run failure), return error.

## Test Plan

- **Objectives**: Verify each error recovery path produces correct behavior.
- **Mocking Strategy**: Use the command mock from 48-4 to simulate failure modes.
- **Key Scenarios**:
  1. Non-zero exit → falls back to cached output, isStale=true.
  2. Unparseable JSON → falls back to cached output, isStale=true.
  3. Session corruption → deletes session ID, retries without --resume, succeeds.
  4. Session corruption + retry fails → falls back to cache.
  5. Rate limit → retries with backoff, eventually succeeds.
  6. Rate limit + all retries exhausted → falls back to cache.
  7. First-run failure with no cache → returns error.
- **Success Criteria**: Every failure mode has a defined recovery path; memory files are never deleted.

## Verification

- All 9 recovery tests pass (including new session corruption retry fail test)
- `go test -race ./internal/pm/` passes
- `go vet ./internal/pm/` clean
- AI review: 0 critical, 0 high, 1 medium (resolved — added missing test), 5 low (deferred: broader isRateLimitError fallback, error context on delete failure, package-level sleepFn, cache miss comment, t.Cleanup for sleep restore)

## Files Modified

- `internal/pm/recovery.go` (new) — InvokeWithRecovery, invokeWithRateLimitRetries, isSessionCorruptionError, isRateLimitError
- `internal/pm/recovery_test.go` (new) — 9 test cases covering all recovery paths
- `internal/pm/invoker_test.go` (modified) — added "always-corrupt" helper mode
