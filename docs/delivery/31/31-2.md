# [31-2] Implement search state and n/N match cycling in session list

[Back to task list](./tasks.md)

## Description

Add model fields and key handling to support vim-style search behaviour: track match indices, maintain a current match pointer, handle `n`/`N` for cycling, and make search persist after `Enter`.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2026-02-07 16:37:51 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2026-02-07 16:49:54 | Status Change | Proposed | InProgress | Started implementation | AI_Agent |
| 2026-02-07 16:51:15 | Status Change | InProgress | Review | Implementation complete, ready for review | AI_Agent |
| 2026-02-09 16:12:00 | Status Change | Review | Done | Task completed and verified | AI_Agent |

## Requirements

- Add model fields: `searchMatches []int` (indices of matching sessions in the visible list), `currentMatchIdx int` (position within searchMatches)
- Recompute matches whenever the search query changes or the session list updates
- `n` key: jump cursor to next match (wrap around from last to first). Only active when a search query exists; otherwise fall through to existing "new session" behaviour
- `N` key: jump cursor to previous match (wrap around from first to last)
- `Enter` performs the default action (attach) but does NOT clear search state — search persists
- Only `Esc` clears search query, match state, and highlights
- `getFilteredSessions()` no longer filters by search — all sessions remain visible regardless of search query
- Match state updates when the underlying session list changes (sessions added/removed/status changed)

## Implementation Plan

1. Add `searchMatches []int` and `currentMatchIdx int` to the Model struct
2. Create a `computeSearchMatches()` method that runs `findMatches` against the currently visible (post-filter, post-sort) session list
3. Call `computeSearchMatches()` after any search query change or session list update
4. In `updateSearchMode()`: on `Enter`, exit input mode but keep `searchQuery` populated (search persists)
5. In main key handling: when `searchQuery != ""`, intercept `n` to call a `nextMatch()` method, `N` to call `prevMatch()`
6. When `searchQuery == ""`, `n` retains existing "new session" behaviour
7. `nextMatch()`: increment `currentMatchIdx`, wrap around, move cursor to `searchMatches[currentMatchIdx]`
8. `prevMatch()`: decrement `currentMatchIdx`, wrap around, move cursor to `searchMatches[currentMatchIdx]`
9. `Esc` clears `searchQuery`, `searchMatches`, and `currentMatchIdx`

## Test Plan

- Test `n`/`N` cycling with multiple matches, single match, no matches
- Test wrap-around in both directions
- Test search persistence after `Enter`
- Test `Esc` clears all search state
- Test `n` falls through to "new session" when no search query active
- Test match recomputation when session list changes

## Verification

- [ ] `n` jumps to next match when search is active
- [ ] `N` jumps to previous match when search is active
- [ ] Cycling wraps around in both directions
- [ ] `Enter` does not clear search state
- [ ] `Esc` clears all search state
- [ ] `n` opens new session dialog when no search query
- [ ] Match indices recompute on session list changes
- [ ] Tests pass

## Files Modified

- `internal/tui/model.go` — Added searchMatches/currentMatchIdx fields, computeSearchMatches(), nextMatch(), prevMatch(), clearSearchState() methods; updated n/N/Esc/Enter key handling for vim-style search
